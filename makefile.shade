use assembly="System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
use assembly="System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
use import="Environment"
use import="Regex"
use namespace="System.IO"
use namespace="System.Linq"
use namespace="System.Xml.Linq"

var PRODUCT_VERSION = '1.0.0'
var AUTHORS='Microsoft Open Technologies, Inc.'

use-standard-lifecycle
k-standard-goals

var Configuration2='${E("Configuration")}'
var ROOT = '${Directory.GetCurrentDirectory()}'
var SCRIPTS_DIR = '${Path.Combine(ROOT, "scripts")}'
var ARTIFACTS_DIR = '${Path.Combine(ROOT, "artifacts")}'
var BUILD_DIR2 = '${Path.Combine(ROOT, "artifacts", "build")}'
var NUSPEC_ROOT = '${Path.Combine(ROOT, "nuspec")}'
var TEST_RESULTS = '${Path.Combine(ROOT, "artifacts", "TestResults")}'
var SAMPLES_DIR = '${Path.Combine(ROOT, "samples")}'
var FULL_VERSION = '${PRODUCT_VERSION + "-" + E("DNX_BUILD_VERSION")}'
var CORECLR_TARGET_PATH = '${Path.Combine(BUILD_DIR2, "CoreCLR")}'
var RUNTIME_NAME_PREFIX = 'dnx-'

- // Runtime names

var RUNTIME_MONO_NAME = '${RUNTIME_NAME_PREFIX + "mono"}'
var RUNTIME_CLR_WIN_x86_NAME = '${RUNTIME_NAME_PREFIX + "clr-win-x86"}'
var RUNTIME_CLR_WIN_x64_NAME = '${RUNTIME_NAME_PREFIX + "clr-win-x64"}'
var RUNTIME_CORECLR_WIN_x86_NAME = '${RUNTIME_NAME_PREFIX + "coreclr-win-x86"}'
var RUNTIME_CORECLR_WIN_x64_NAME = '${RUNTIME_NAME_PREFIX + "coreclr-win-x64"}'
var RUNTIME_CORECLR_DARWIN_x64_NAME = '${RUNTIME_NAME_PREFIX + "coreclr-darwin-x64"}'
var RUNTIME_CORECLR_LINUX_x64_NAME = '${RUNTIME_NAME_PREFIX + "coreclr-linux-x64"}'

- // Runtime paths
var RUNTIME_MONO_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_MONO_NAME, "bin")}'
var RUNTIME_CLR_WIN_x86_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CLR_WIN_x86_NAME, "bin")}'
var RUNTIME_CLR_WIN_x64_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CLR_WIN_x64_NAME, "bin")}'
var RUNTIME_CORECLR_WIN_x86_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CORECLR_WIN_x86_NAME, "bin")}'
var RUNTIME_CORECLR_WIN_x64_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CORECLR_WIN_x64_NAME, "bin")}'
var RUNTIME_CORECLR_DARWIN_x64_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CORECLR_DARWIN_x64_NAME, "bin")}'
var RUNTIME_CORECLR_LINUX_x64_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CORECLR_LINUX_x64_NAME, "bin")}'

var RUNTIME_CLR_TARGETS = '${new [] {RUNTIME_MONO_BIN, RUNTIME_CLR_WIN_x86_BIN, RUNTIME_CLR_WIN_x64_BIN}}'
var RUNTIME_CORECLR_TARGETS = '${new [] {RUNTIME_CORECLR_WIN_x86_BIN, RUNTIME_CORECLR_WIN_x64_BIN, RUNTIME_CORECLR_DARWIN_x64_BIN, RUNTIME_CORECLR_LINUX_x64_BIN}}'
var ALL_TARGETS = '${RUNTIME_CLR_TARGETS.Concat(RUNTIME_CORECLR_TARGETS)}'

var RUNTIME_COMMON_NAME = 'DNX'
var BOOTSTRAPPER_EXE_NAME = 'dnx'
var BOOTSTRAPPER_DLL_NAME = 'dnx.bootstrapper'
var BOOTSTRAPPER_CLR_NAME = 'dnx.clr'
var BOOTSTRAPPER_CORECLR_NAME = 'dnx.coreclr'
var BOOTSTRAPPER_CLR_MANAGED_NAME = '${BOOTSTRAPPER_CLR_NAME + ".managed"}'
var BOOTSTRAPPER_CORECLR_MANAGED_NAME = '${BOOTSTRAPPER_CORECLR_NAME + ".managed"}'
var BOOTSTRAPPER_MONO_MANAGED_NAME = 'dnx.mono.managed'
var BOOTSTRAPPER_HOST_NAME = 'dnx.host'

var PROGRAM_FILES_X86 = '${Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86)}'
var MSBUILD = '${Path.Combine(PROGRAM_FILES_X86, "MSBuild", "14.0", "Bin", "MSBuild.exe")}'
var CLANG = '${SearchForClang()}'

var MANAGED_PROJECTS = '${FindAllProjects(
    BOOTSTRAPPER_HOST_NAME,
    BOOTSTRAPPER_CORECLR_MANAGED_NAME,
    "Microsoft.Framework.ApplicationHost",
    "Microsoft.Framework.CommandLineUtils.Sources",
    "Microsoft.Framework.DesignTimeHost",
    "Microsoft.Framework.DesignTimeHost.Abstractions",
    "Microsoft.Framework.PackageManager",
    "Microsoft.Framework.Project",
    "Microsoft.Framework.Runtime",
    "Microsoft.Framework.Runtime.Caching",
    "Microsoft.Framework.Runtime.Abstractions",
    "Microsoft.Framework.Runtime.Compilation.DesignTime",
    "Microsoft.Framework.Runtime.Sources",
    "Microsoft.Framework.Runtime.Loader",
    "Microsoft.Framework.Runtime.Roslyn",
    "Microsoft.Framework.Runtime.Roslyn.Abstractions",
    "Microsoft.Framework.Runtime.Roslyn.Common")}'

var WIN_MANAGED_PROJECTS = '${FindAllProjects(
    BOOTSTRAPPER_CLR_MANAGED_NAME)}'

var RC_FILES = '${FindAllFiles("Resource.rc", BOOTSTRAPPER_DLL_NAME, BOOTSTRAPPER_CLR_NAME, BOOTSTRAPPER_CORECLR_NAME)}'

var RUNTIME_TARGETS='${new List<RuntimeTarget>()}'

@{
    // Always build mono
    RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_MONO_NAME, TargetFolder = RUNTIME_MONO_BIN, Framework = "dnx451", Arch = "any", OS = "any", Flavor = "mono" });

    if (CanBuildForWindows)
    {
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CLR_WIN_x86_NAME,     TargetFolder = RUNTIME_CLR_WIN_x86_BIN,     Framework = "dnx451",     Arch = "x86", OS = "win", Flavor = "clr" });
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CLR_WIN_x64_NAME,     TargetFolder = RUNTIME_CLR_WIN_x64_BIN,     Framework = "dnx451",     Arch = "x64", OS = "win", Flavor = "clr" });
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CORECLR_WIN_x86_NAME, TargetFolder = RUNTIME_CORECLR_WIN_x86_BIN, Framework = "dnxcore50",  Arch = "x86", OS = "win", Flavor = "coreclr" });
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CORECLR_WIN_x64_NAME, TargetFolder = RUNTIME_CORECLR_WIN_x64_BIN, Framework = "dnxcore50",  Arch = "x64", OS = "win", Flavor = "coreclr" });
    }

    if (CanBuildForLinux)
    {
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CORECLR_LINUX_x64_NAME, TargetFolder = RUNTIME_CORECLR_LINUX_x64_BIN,  Framework = "dnxcore50",  Arch = "x64", OS = "linux", Flavor = "coreclr" });
    }

    if (CanBuildForDarwin)
    {
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CORECLR_DARWIN_x64_NAME, TargetFolder = RUNTIME_CORECLR_DARWIN_x64_BIN, Framework = "dnxcore50",  Arch = "x64", OS = "darwin", Flavor = "coreclr" });
    }
}

-// Replace repo-initialize with a less greedy restore
#repo-initialize target='initialize'
    git gitCommand="submodule update --init"
    @{
        DoRestore();
    }

- // k-standard-goal overrides
#native-compile

#build-compile target='compile'
#package-runtime .clean-sdk-dir target='package'

#xunit-test

-// Specific to building the dnx
#build-common target='build-compile'
#package-common target='package-runtime'

-// Define platform specific builds as a n00p if the current platform can't produce a build
#build-darwin target='build-compile' if='CanBuildForDarwin'
#build-darwin if='!CanBuildForDarwin'

#package-darwin target='package-runtime' if='CanBuildForDarwin'
#package-darwin if='CanBuildForDarwin'

#build-linux target='build-compile' if='CanBuildForLinux'
#build-linux if='!CanBuildForLinux'

#package-linux target='package-runtime' if='CanBuildForLinux'
#package-linux if='CanBuildForLinux'

#build-windows target='build-compile' if='CanBuildForWindows'
#build-windows if='!CanBuildForWindows'

#package-windows target='package-runtime' if='CanBuildForWindows'
#package-windows if='!CanBuildForWindows'

- // ===================== BUILD ===================== 

- // ===================== COMMON ===================== 

#build-managed-projects target='build-common'
    @{ var BUILD_DIR = BUILD_DIR2; }
    kpm-pack each='var projectFile in MANAGED_PROJECTS' configuration='${Configuration2}' kpmPackOutputDir='${BUILD_DIR}'
    @{
        foreach (var nupkg in Files.Include(Path.Combine(BUILD_DIR, "*/*.nupkg"))) 
        {
            File.Copy(nupkg, Path.Combine(BUILD_DIR, Path.GetFileName(nupkg)), true);
        }
    }

-// This target's build-cmmon since mono is built on all platforms
#build-dnx-mono-bootstrapper target='build-common'
    var monoManagedOutpath='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_MONO_MANAGED_NAME)}'
    directory create='${monoManagedOutpath}'
    @{
        var bootstrapperAssembly = Path.Combine(BUILD_DIR2, BOOTSTRAPPER_HOST_NAME, "dnx451", BOOTSTRAPPER_HOST_NAME + ".dll");

        var sourceFiles = new string[] 
        {
            Path.Combine("src", BOOTSTRAPPER_MONO_MANAGED_NAME, "EntryPoint.cs"),
            Path.Combine("src", "Microsoft.Framework.CommandLineUtils.Sources", "CommandLine", "CommandArgument.cs"),
            Path.Combine("src", "Microsoft.Framework.CommandLineUtils.Sources", "CommandLine", "CommandLineApplication.cs"), 
            Path.Combine("src", "Microsoft.Framework.CommandLineUtils.Sources", "CommandLine", "CommandOption.cs"), 
            Path.Combine("src", "Microsoft.Framework.CommandLineUtils.Sources", "CommandLine", "CommandOptionType.cs"),
            Path.Combine("src", "Microsoft.Framework.Runtime.Sources", "Impl", "EnvironmentNames.cs"),
            Path.Combine("src", "Microsoft.Framework.Runtime.Sources", "Impl", "Constants.cs")
        };

        var arguments = string.Format(
            @"/target:exe /nologo /unsafe /out:""{0}"" /r:""{1}"" /define:DNX451 {2}",
            Path.Combine(monoManagedOutpath, BOOTSTRAPPER_MONO_MANAGED_NAME + ".dll"),
            bootstrapperAssembly,
            string.Join(" ", sourceFiles));

        var compiler = IsMono ? "mcs" : Path.Combine(Environment.GetEnvironmentVariable("WINDIR"), "Microsoft.NET", "Framework", "v4.0.30319", "csc.exe");

        Exec(compiler, arguments);
    }

#clean-sdk-dir
    directory each='var delete in ALL_TARGETS.Select(t => Path.GetDirectoryName(t))'
    directory each='var create in RUNTIME_TARGETS.Select(t => t.TargetFolder)'

- // ===================== WINDOWS ===================== 

#build-win-managed-projects target='build-windows'
    @{ var BUILD_DIR = BUILD_DIR2; }
    kpm-pack each='var projectFile in WIN_MANAGED_PROJECTS' configuration='${Configuration2}' kpmPackOutputDir='${BUILD_DIR}'
    @{
        foreach (var nupkg in Files.Include(Path.Combine(BUILD_DIR, "*/*.nupkg"))) 
        {
            File.Copy(nupkg, Path.Combine(BUILD_DIR, Path.GetFileName(nupkg)), true);
        }
    }

#build-dnx-win-exe .ensure-msbuild .update-rc-files target='build-windows'
    var bootstrapperProj = '${Path.Combine(ROOT, @"src\dnx.windows\dnx.windows.vcxproj")}'
    @{   
        var environmentRuntimeTargetOS = Environment.GetEnvironmentVariable("RUNTIME_TARGET_OS");
        var configRuntimeTargetOS = "";
        
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=Win32;TargetFramework=dnx451;RuntimeType=CLR");
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=x64;TargetFramework=dnx451;RuntimeType=CLR");

        if (environmentRuntimeTargetOS == "WIN7_PLUS_CORESYSTEM")
        {
            configRuntimeTargetOS = ";RuntimeTargetOS=WIN7_PLUS_CORESYSTEM";
        }
            
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=Win32;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN" + configRuntimeTargetOS);
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=x64;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN" + configRuntimeTargetOS);
    }

    directory delete='${Path.Combine(BUILD_DIR2, "dnx.windows")}'
    copy sourceDir='${Path.Combine(ROOT, @"src\dnx.windows")}' include='bin/**/' outputDir='${Path.Combine(BUILD_DIR2, "dnx.windows")}' overwrite='${true}'


#build-dnx-win-dll .ensure-msbuild .update-rc-files target='build-windows'
    var bootstrapperProj = '${Path.Combine(ROOT, @"src\dnx\dnx.vcxproj")}'
    @{       
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=Win32;TargetFramework=dnx451;RuntimeType=CLR;BuildForOneCore=False");
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=x64;TargetFramework=dnx451;RuntimeType=CLR;BuildForOneCore=False");
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=Win32;TargetFramework=dnx451;RuntimeType=CLR;BuildForOneCore=True");
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=x64;TargetFramework=dnx451;RuntimeType=CLR;BuildForOneCore=True");

        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=Win32;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN;BuildForOneCore=False");
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=x64;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN;BuildForOneCore=False");
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=Win32;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN;BuildForOneCore=True");
        Exec(MSBUILD, bootstrapperProj + " /p:Configuration=" + Configuration2 + ";Platform=x64;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN;BuildForOneCore=True");        
    }

    directory delete='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_EXE_NAME)}'
    copy sourceDir='${Path.Combine(ROOT, @"src\dnx")}' include='bin/**/' outputDir='${Path.Combine(BUILD_DIR2, "dnx")}' overwrite='${true}'

#build-dnx-coreclr-win-bootstrapper .ensure-msbuild .update-tpa .update-rc-files target='build-windows'
    var bootstrapperCoreClrProj = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME, BOOTSTRAPPER_CORECLR_NAME + ".vcxproj")}'

    @{
        var environmentRuntimeTargetOS = Environment.GetEnvironmentVariable("RUNTIME_TARGET_OS");
        var configRuntimeTargetOS = "";
        
        if (environmentRuntimeTargetOS == "WIN7_PLUS_CORESYSTEM")
        {
            configRuntimeTargetOS = ";RuntimeTargetOS=WIN7_PLUS_CORESYSTEM";
        }

        Exec(MSBUILD, bootstrapperCoreClrProj + " /p:Configuration=" + Configuration2 + ";Platform=Win32" + configRuntimeTargetOS);
        Exec(MSBUILD, bootstrapperCoreClrProj + " /p:Configuration=" + Configuration2 + ";Platform=x64" + configRuntimeTargetOS);
    }

    directory delete='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME)}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME)}' include='bin/**/' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME)}' overwrite='${true}'

#build-dnx-clr-win-bootstrapper .ensure-msbuild .update-rc-files target='build-windows'
    var bootstrapperClrProj ='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CLR_NAME, BOOTSTRAPPER_CLR_NAME + ".vcxproj")}'

    @{
        Exec(MSBUILD, bootstrapperClrProj + " /p:Configuration=" + Configuration2 + ";Platform=Win32");
        Exec(MSBUILD, bootstrapperClrProj + " /p:Configuration=" + Configuration2 + ";Platform=x64");
    }

    directory delete='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME)}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CLR_NAME)}' include='bin/**/' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME)}' overwrite='${true}' 

#update-rc-files if='!IsMono'
    if condition='IsTeamCity'
        for each='var rcfile in RC_FILES'
            @{
                var digitVer = PRODUCT_VERSION.Replace(".", ",") + ",0";

                var productVersionStructMatcher = @"PRODUCTVERSION \d+,\d+,\d+,\d+";
                var productVersionValueMatcher = @"VALUE ""ProductVersion"", ""[^""]+""";
                var productVersionStruct = "PRODUCTVERSION " + digitVer;
                var productVersionValue = "VALUE \"ProductVersion\", \"" + FULL_VERSION + "\"";

                var fileVersionStructMatcher = @"FILEVERSION \d+,\d+,\d+,\d+";
                var fileVersionValueMatcher = @"VALUE ""FileVersion"", ""[^""]+""";
                var fileVersionStruct = "FILEVERSION " + digitVer;
                var fileVersionValue = "VALUE \"FileVersion\", \"" + FULL_VERSION + "\"";
            }
            update-file updateFile="${rcfile}" @{
                updateText = RegexReplace(updateText, productVersionStructMatcher, productVersionStruct);
                updateText = RegexReplace(updateText, productVersionValueMatcher, productVersionValue);
                updateText = RegexReplace(updateText, fileVersionStructMatcher, fileVersionStruct);
                updateText = RegexReplace(updateText, fileVersionValueMatcher, fileVersionValue);
            }

- // ===================== LINUX ===================== 

#build-dnx-coreclr-linux-bootstrapper .ensure-clang .update-tpa target='build-linux'
    var soOutputDir = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME + ".unix", "bin")}'
    var soOutputPath = '${Path.Combine(soOutputDir, BOOTSTRAPPER_CORECLR_NAME + ".so")}'
    @{
        var sourceFiles = new string[] 
        {
            Path.Combine("src", BOOTSTRAPPER_CORECLR_NAME + ".unix", "tpa.cpp"),
            Path.Combine("src", BOOTSTRAPPER_CORECLR_NAME + ".unix", BOOTSTRAPPER_CORECLR_NAME + ".cpp")
        };

        Directory.CreateDirectory(soOutputDir);

        Exec(CLANG, string.Format("-fPIC -shared {0} -g -o {1} -DPLATFORM_LINUX --std=c++11 -ldl", string.Join(" ", sourceFiles), soOutputPath));
    }

    copy sourceDir='${soOutputDir}' include='*.so' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME + ".unix")}' overwrite='${true}'

#build-dnx-linux-bootstrapper .ensure-clang target='build-linux'
    var soOutputDir = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_EXE_NAME, "bin", "x64")}'
    var soOutputPath = '${Path.Combine(soOutputDir, BOOTSTRAPPER_EXE_NAME)}'
    @{
        var sourceFiles = new string[] 
        {
            Path.Combine("src", BOOTSTRAPPER_EXE_NAME, BOOTSTRAPPER_EXE_NAME + ".cpp"),
            Path.Combine("src", BOOTSTRAPPER_EXE_NAME, "pal.unix.cpp"),
            Path.Combine("src", BOOTSTRAPPER_EXE_NAME, "pal.linux.cpp"),
            Path.Combine("src", BOOTSTRAPPER_EXE_NAME, "tchar.cpp"),
        };

        Directory.CreateDirectory(soOutputDir);

        Exec(CLANG, string.Format("{0} -g -o {1} -DCORECLR_LINUX -DPLATFORM_UNIX -std=c++11 -ldl", string.Join(" ", sourceFiles), soOutputPath));
    }

    copy sourceDir='${soOutputDir}' include='*' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_EXE_NAME, "bin", "linux", "x64")}' overwrite='${true}'


- // ===================== DARWIN (OSX) ===================== 

#build-dnx-coreclr-darwin-bootstrapper .ensure-clang .update-tpa target='build-darwin'
    var soOutputDir = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME + ".unix", "bin")}'
    var soOutputPath = '${Path.Combine(soOutputDir, BOOTSTRAPPER_CORECLR_NAME + ".dylib")}'
    @{
        var sourceFiles = new string[]
        {
            Path.Combine("src", BOOTSTRAPPER_CORECLR_NAME + ".unix", "tpa.cpp"),
            Path.Combine("src", BOOTSTRAPPER_CORECLR_NAME + ".unix", BOOTSTRAPPER_CORECLR_NAME + ".cpp")
        };

        Directory.CreateDirectory(soOutputDir);

        Exec(CLANG, string.Format("-fPIC -shared {0} -g -o {1} -DPLATFORM_DARWIN --std=c++11 -ldl", string.Join(" ", sourceFiles), soOutputPath));
    }

    copy sourceDir='${soOutputDir}' include='*.dylib' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME + ".unix")}' overwrite='${true}'

#build-dnx-darwin-bootstrapper .ensure-clang target='build-darwin'
    var soOutputDir = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_EXE_NAME, "bin", "x64")}'
    var soOutputPath = '${Path.Combine(soOutputDir, BOOTSTRAPPER_EXE_NAME)}'
    @{
        var sourceFiles = new string[]
        {
            Path.Combine("src", BOOTSTRAPPER_EXE_NAME, BOOTSTRAPPER_EXE_NAME + ".cpp"),
            Path.Combine("src", BOOTSTRAPPER_EXE_NAME, "pal.unix.cpp"),
            Path.Combine("src", BOOTSTRAPPER_EXE_NAME, "pal.darwin.cpp"),
            Path.Combine("src", BOOTSTRAPPER_EXE_NAME, "tchar.cpp"),
        };

        Directory.CreateDirectory(soOutputDir);

        Exec(CLANG, string.Format("{0} -g -o {1} -DCORECLR_DARWIN -DPLATFORM_UNIX -std=c++11 -ldl", string.Join(" ", sourceFiles), soOutputPath));
    }

    copy sourceDir='${soOutputDir}' include='*' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_EXE_NAME, "bin", "darwin", "x64")}' overwrite='${true}'

- // ===================== PACKAGE ===================== 

#copy-coreclr
    @{
        var extras = "-pre";
        var coreCLRPackageSource = E("CORECLR_PACKAGE_SOURCE");
        if (!string.IsNullOrEmpty(coreCLRPackageSource))
        {
            extras += " -source " + coreCLRPackageSource;
        }

        if (IsTeamCity)
        {
            extras += " -nocache";
        }

        var downloadComplete = false;
        // Travis ci has a timelimit for no activity and the CoreCLR pacakge is
        // about 51MB. We're going to print to the console while this is happening 
        // so the build doesn't timeout
        if (IsTravis)
        {
            new System.Threading.Thread(() => 
            {
                while (!downloadComplete)
                {
                    Console.Write(".");
                    System.Threading.Thread.Sleep(1000);
                }

                Console.WriteLine();
            }) 
            {
                IsBackground = true
            }
            .Start();
        }
    }

    nuget-install package='CoreCLR' outputDir='packages' extra='${extras}' once='CoreCLR' nugetPath='.nuget/nuget.exe' if='!Directory.Exists(CORECLR_TARGET_PATH)'

    var CoreCLR_DIR='${""}'
    @{
        downloadComplete = true;

        Func<string, long> getVersion = version => {
        var dash = version.LastIndexOf('-');

            if(dash != -1)
            {
                var lastToken = version.Substring(dash + 1);

                if(lastToken.StartsWith("t"))
                {
                    return Int64.Parse(lastToken.Substring(1));
                }

                return Int64.Parse(lastToken);
            }
            return Int64.MaxValue;
        };

        string packagesDir = Path.Combine(Directory.GetCurrentDirectory(), "packages");
        CoreCLR_DIR = Directory.EnumerateDirectories(packagesDir, "CoreCLR*")
                                .OrderByDescending(getVersion)
                                .First();
                                      
        Log.Info("Using " + CoreCLR_DIR);
    }
    
    -// Copy to target
    copy sourceDir='${Path.Combine(CoreCLR_DIR, "Runtime")}' outputDir='${Path.Combine(CORECLR_TARGET_PATH, "Runtime")}' overwrite='${true}' if='!Directory.Exists(CORECLR_TARGET_PATH)'

#copy-required-dependencies
     @{
        var runtimeProjects = new[]
        {
            "Microsoft.Framework.Runtime.Roslyn",
            "Microsoft.Framework.ApplicationHost",
            "Microsoft.Framework.Runtime.Compilation.DesignTime",
            BOOTSTRAPPER_HOST_NAME, 
            BOOTSTRAPPER_CORECLR_MANAGED_NAME 
        };

        var sdkProjects = new[]
        {
            "Microsoft.Framework.DesignTimeHost",
            "Microsoft.Framework.PackageManager",
            "Microsoft.Framework.Project"
        };

        foreach (var target in RUNTIME_TARGETS)
        {
            var coreclrFolder = target.Flavor == "coreclr" ? Path.Combine(CORECLR_TARGET_PATH, "Runtime", target.OS, target.Arch) : null;

            // Parse and copy runtime assemblies
            var runtimeAssemblies = new HashSet<string>();

            foreach (var project in runtimeProjects)
            {
                if (project == BOOTSTRAPPER_CORECLR_MANAGED_NAME && target.Flavor != "coreclr")
                {
                    continue;
                }

                var projectFolder = Path.Combine(ROOT, "src", project);
                var projectAssemblies = ListDependencyAssemblies(projectFolder, target.Framework, coreclrFolder);

                try
                {
                    foreach (var file in projectAssemblies)
                    {
                        if (runtimeAssemblies.Add(file))
                        {
                            var targetFilePath = Path.Combine(target.TargetFolder, Path.GetFileName(file));
                            Log.Info("Copying " + file + " to " + targetFilePath);
                            File.Copy(file, targetFilePath, true);
                        }
                    }
                }
                catch (Exception ex)
                {
                    throw new InvalidOperationException(string.Format("Fail to copy runtime assemblies [{0}]", ex.Message));
                }
            }

            // Parse and copy lib assemblies
            foreach (var project in sdkProjects)
            {
                var projectFolder = Path.Combine(ROOT, "src", project);
                var projectAssemblies = ListDependencyAssemblies(projectFolder, target.Framework, coreclrFolder);

                projectAssemblies.ExceptWith(runtimeAssemblies);

                var targetLibDir = Path.Combine(target.TargetFolder, "lib", project);

                Directory.CreateDirectory(targetLibDir);

                foreach (var file in projectAssemblies)
                {
                    var targetFilePath = Path.Combine(targetLibDir, Path.GetFileName(file));
                    Log.Info("Copying " + file + " to " + targetFilePath);
                    File.Copy(file, targetFilePath, true);
                }
            }

            // Copy required CoreCLR assemblies
            if (target.Flavor == "coreclr")
            {
                var extraBinaries = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
                {
                    "System.Private.DataContractSerialization.dll",
                    "System.Private.Networking.dll",
                    "System.Private.ServiceModel.dll"
                };

                if (target.OS != "win")
                {
                    // For now, we ship cross platform specific binaries as part of DNX for Linux and Darwin, since
                    // the versions in NuGet are Windows specific.

                    extraBinaries.Add("Microsoft.Win32.Primitives.dll");
                    extraBinaries.Add("System.Console.dll");
                    extraBinaries.Add("System.Data.SqlClient.dll");
                    extraBinaries.Add("System.Diagnostics.Debug.dll");
                    extraBinaries.Add("System.Diagnostics.FileVersionInfo.dll");
                    extraBinaries.Add("System.Diagnostics.Process.dll");
                    extraBinaries.Add("System.Diagnostics.TraceSource.dll");
                    extraBinaries.Add("System.Globalization.Extensions.dll");
                    extraBinaries.Add("System.IO.Compression.dll");
                    extraBinaries.Add("System.IO.FileSystem.dll");
                    extraBinaries.Add("System.IO.FileSystem.DriveInfo.dll");
                    extraBinaries.Add("System.IO.FileSystem.Watcher.dll");
                    extraBinaries.Add("System.IO.MemoryMappedFiles.dll");
                    extraBinaries.Add("System.IO.Pipes.dll");
                    extraBinaries.Add("System.Net.Security.dll");
                    extraBinaries.Add("System.Runtime.Extensions.dll");
                    extraBinaries.Add("System.Security.Cryptography.Encoding.dll");
                    extraBinaries.Add("System.Security.Cryptography.Encryption.dll");
                    extraBinaries.Add("System.Security.Cryptography.Encryption.Aes.dll");
                    extraBinaries.Add("System.Security.Cryptography.Hashing.dll");
                    extraBinaries.Add("System.Security.Cryptography.Hashing.Algorithms.dll");
                    extraBinaries.Add("System.Security.Cryptography.RandomNumberGenerator.dll");
                    extraBinaries.Add("System.Security.SecureString.dll");
                    extraBinaries.Add("System.Text.Encoding.CodePages.dll");
                    extraBinaries.Add("System.Threading.dll");

                    var nativeExtension = target.OS == "linux" ? ".so" : ".dylib";

                    extraBinaries.Add("System.Security.Cryptography.Native" + nativeExtension);
                }

                foreach (var file in Directory.GetFiles(coreclrFolder).Where(f => extraBinaries.Contains(Path.GetFileName(f)) || !Path.GetFileName(f).StartsWith("System")))
                {
                    var targetFilePath = Path.Combine(target.TargetFolder, Path.GetFileName(file));
                    Log.Info("Copying " + file + " to " + targetFilePath);
                    File.Copy(file, targetFilePath, true);
                }

                // Copy the managed resources the runtime needs for Linux
                if (target.OS == "linux")
                {
                    foreach (var file in Files.BasePath(coreclrFolder).Include("**/*.mo"))
                    {
                        var sourceFile = Path.Combine(coreclrFolder, file);
                        var outputFile = Path.Combine(target.TargetFolder, file);

                        if (!Directory.Exists(Path.GetDirectoryName(outputFile)))
                        {
                            Directory.CreateDirectory(Path.GetDirectoryName(outputFile));
                        }

                        Log.Info("Copying " + sourceFile + " to " + outputFile);
                        File.Copy(sourceFile, outputFile, true);
                    }
                }
            }
        }
    }


#copy-common .copy-coreclr .copy-required-dependencies target='package-common'
    copy sourceDir='${SCRIPTS_DIR}' include='*.sh' outputDir='${RUNTIME_MONO_BIN}' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_MONO_MANAGED_NAME)}' outputDir='${RUNTIME_MONO_BIN}' include='*.dll' overwrite='${true}'
    @{
        FixShFiles(RUNTIME_MONO_BIN);
    }
    
    -// Copy built projects to the appropriate locations

    @{
        var dnxCore50Pattern = Path.Combine(BUILD_DIR2, "*", "dnxcore50", "**.*");
        var dnx451Pattern = Path.Combine(BUILD_DIR2, "*", "dnx451", "**.*");

        var libPackages = new[] { "Microsoft.Framework.Project",
                                  "Microsoft.Framework.PackageManager", 
                                  "Microsoft.Framework.DesignTimeHost" };

        var sharedSourceAssemblies = new [] { 
            Path.Combine(BUILD_DIR2, "Microsoft.Framework.CommandLineUtils.Sources/**/*.*"), 
            Path.Combine(BUILD_DIR2, "Microsoft.Framework.Runtime.Sources/**/*.*"),
        };
        
        foreach (var file in Files.Include(dnxCore50Pattern).Exclude(sharedSourceAssemblies))
        {
            foreach (var runtimeTarget in RUNTIME_TARGETS.Where(t => t.Flavor == "coreclr"))
            {
                string dest = Path.Combine(runtimeTarget.TargetFolder, Path.GetFileName(file));
                File.Copy(file, dest, true);
            }
        }
        
        foreach (var file in Files.Include(dnx451Pattern).Exclude(sharedSourceAssemblies))
        {
            foreach (var runtimeTarget in RUNTIME_TARGETS.Where(t => t.Flavor != "coreclr"))
            {
                string dest = Path.Combine(runtimeTarget.TargetFolder, Path.GetFileName(file));
                File.Copy(file, dest, true);
            }
        }

        // Clean up net45.managed from mono (it's never used)
        File.Delete(Path.Combine(RUNTIME_MONO_BIN, BOOTSTRAPPER_CLR_MANAGED_NAME + ".dll"));

        Action<string, string, string> move = (binFolder, name, extension) =>
        {
            var libPath = Path.Combine(binFolder, "lib", name);
            var source = Path.Combine(binFolder, name + extension);
            var target = Path.Combine(libPath, name + extension);
            
            if (File.Exists(source))
            {
                if (File.Exists(target))
                {
                    File.Delete(target);
                }
                
                Directory.CreateDirectory(libPath);
                File.Move(source, target);

                Log.Info("Moving " + name + " to " + target);
            }
            else
            {
                Log.Warn(source + " does not exist in " + binFolder);
            }
        };
        
        // Move some packages into the lib/ folder
        foreach (var libPackage in libPackages)
        {
            foreach (var runtimeTarget in RUNTIME_TARGETS)
            {
                move(runtimeTarget.TargetFolder, libPackage, ".dll");
                if (!IsMono)
                {
                    move(runtimeTarget.TargetFolder, libPackage, ".pdb");
                }
            }
        }
    }

#copy-windows-bits target='package-windows'
    -// Runtime for clr-win-x86
    copy sourceDir='${Path.Combine(BUILD_DIR2, "dnx", "bin", "Win32", Configuration2, "dnx451")}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, "dnx.windows", "bin", "Win32", Configuration2, "dnx451")}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.exe' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME, "bin", "Win32", Configuration2)}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME, "bin", "Win32", Configuration2)}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.pdb' overwrite='${true}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CLR_MANAGED_NAME)}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.config' overwrite='${true}'

    -// Runtime for clr-win-x64
    copy sourceDir='${Path.Combine(BUILD_DIR2, "dnx", "bin", "x64", Configuration2, "dnx451")}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, "dnx.windows", "bin", "x64", Configuration2, "dnx451")}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.exe' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME, "bin", "x64", Configuration2)}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME, "bin", "x64", Configuration2)}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.pdb' overwrite='${true}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CLR_MANAGED_NAME)}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.config' overwrite='${true}'

    -// Runtime for coreclr-win-x86
    copy sourceDir='${Path.Combine(BUILD_DIR2, "dnx", "bin", "Win32", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_x86_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, "dnx.windows", "bin", "Win32", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_x86_BIN}' include='*.exe' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "Win32", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_x86_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "Win32", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_x86_BIN}' include='*.pdb' overwrite='${true}'

    -// Runtime for coreclr-win-x64
    copy sourceDir='${Path.Combine(BUILD_DIR2, "dnx", "bin", "x64", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_x64_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, "dnx.windows", "bin", "x64", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_x64_BIN}' include='*.exe' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "x64", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_x64_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "x64", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_x64_BIN}' include='*.pdb' overwrite='${true}'

    -// Copy cmd files
    copy sourceDir='${SCRIPTS_DIR}' include='*.cmd' exclude='k-crossgen.cmd' overwrite='${true}' each='var outputDir in new[]{ RUNTIME_CLR_WIN_x86_BIN, RUNTIME_CLR_WIN_x64_BIN}'
    copy sourceDir='${SCRIPTS_DIR}' include='*.cmd' overwrite='${true}' each='var outputDir in new[]{ RUNTIME_CORECLR_WIN_x86_BIN, RUNTIME_CORECLR_WIN_x64_BIN }'

#copy-linux-bits target='package-linux'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME + ".unix")}' include='*.so' outputDir='${RUNTIME_CORECLR_LINUX_x64_BIN}' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_EXE_NAME, "bin", "linux", "x64")}' include='dnx' outputDir='${RUNTIME_CORECLR_LINUX_x64_BIN}' overwrite='${true}'
    copy sourceDir='${SCRIPTS_DIR}' include='dnu.sh' outputDir='${RUNTIME_CORECLR_LINUX_x64_BIN}' overwrite='${true}'
    @{
        FixShFiles(RUNTIME_CORECLR_LINUX_x64_BIN);
    }

var CI_LINUX_DROP_PATH = '${Environment.GetEnvironmentVariable("CI_LINUX_DROP_PATH")}'

#copy-ci-linux-bits target='package-runtime' if='!string.IsNullOrEmpty(CI_LINUX_DROP_PATH)'
    @{
        var extractDirectory = Path.Combine(ARTIFACTS_DIR, "Dnx.Linux");
    }

    copy sourceDir='${CI_LINUX_DROP_PATH}' outputDir='${extractDirectory}' include='*.nupkg' overwrite='${true}'

    @{
        foreach (var package in Directory.EnumerateFiles(extractDirectory, "*.nupkg"))
        {
            var unpackagePath = Path.Combine(extractDirectory, Path.GetFileNameWithoutExtension(package));
            UnzipPackage(package, unpackagePath);

            File.Delete(Path.Combine(unpackagePath, "[Content_Types].xml"));
            Directory.Delete(Path.Combine(unpackagePath, "_rels"), recursive: true);
        }
    }

    nuget-pack packageVersion='${FULL_VERSION}' outputDir='${BUILD_DIR2}' extra='-NoPackageAnalysis' nugetPath='.nuget/nuget.exe' each='var nuspecFile in Files.Include(Path.Combine(extractDirectory, "**", "*.nuspec"))'

#copy-darwin-bits target='package-darwin'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME + ".unix")}' include='*.dylib' outputDir='${RUNTIME_CORECLR_DARWIN_x64_BIN}' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_EXE_NAME, "bin", "darwin", "x64")}' include='dnx' outputDir='${RUNTIME_CORECLR_DARWIN_x64_BIN}' overwrite='${true}'
    copy sourceDir='${SCRIPTS_DIR}' include='dnu.sh' outputDir='${RUNTIME_CORECLR_DARWIN_x64_BIN}' overwrite='${true}'
    @{
        FixShFiles(RUNTIME_CORECLR_DARWIN_x64_BIN);
    }

var CI_DARWIN_DROP_PATH = '${Environment.GetEnvironmentVariable("CI_DARWIN_DROP_PATH")}'

#copy-ci-darwin-bits target='package-runtime' if='!string.IsNullOrEmpty(CI_DARWIN_DROP_PATH)'
    @{
        var extractDirectory = Path.Combine(ARTIFACTS_DIR, "Dnx.Darwin");
    }

    copy sourceDir='${CI_DARWIN_DROP_PATH}' outputDir='${extractDirectory}' include='*.nupkg' overwrite='${true}'

    @{
        foreach (var package in Directory.EnumerateFiles(extractDirectory, "*.nupkg"))
        {
            var unpackagePath = Path.Combine(extractDirectory, Path.GetFileNameWithoutExtension(package));
            UnzipPackage(package, unpackagePath);

            File.Delete(Path.Combine(unpackagePath, "[Content_Types].xml"));
            Directory.Delete(Path.Combine(unpackagePath, "_rels"), recursive: true);
        }
    }

    nuget-pack packageVersion='${FULL_VERSION}' outputDir='${BUILD_DIR2}' extra='-NoPackageAnalysis' nugetPath='.nuget/nuget.exe' each='var nuspecFile in Files.Include(Path.Combine(extractDirectory, "**", "*.nuspec"))'

#nuget-pack-runtime target='package'
    @{
        UpdateAllNuspecs(RUNTIME_TARGETS, NUSPEC_ROOT, BUILD_DIR2);
    }
    nuget-pack packageVersion='${FULL_VERSION}' outputDir='${BUILD_DIR2}' extra='-NoPackageAnalysis -Properties RuntimeNamePrefix=${RUNTIME_NAME_PREFIX}' nugetPath='.nuget/nuget.exe' each='var nuspecFile in Files.Include(Path.Combine(BUILD_DIR2, "*.nuspec"))'

- // ===================== TESTING ===================== 

#test-package target='integration-test'
    - // We want to run functional tests on both CLR flavors (wrt the RUNTIME_TARGETS)
    - // We want to separate function tests from unit tests
    @{
        var binPaths = new Dictionary<string, string>();

        // Unzip all runtime targets
        foreach (var target in RUNTIME_TARGETS)
        {
            var nupkgPath = Files.Include(Path.Combine(BUILD_DIR2, target.Name + ".*.nupkg")).Single();
            // This is bizzare because it needs to be predictable for the functional tests
            // Each runtime must exist in it's own unique root
            var unpackagePath = Path.Combine(ARTIFACTS_DIR, "test", target.Name, "runtimes", Path.GetFileNameWithoutExtension(nupkgPath));
            var binPath = Path.Combine(unpackagePath, "bin");

            Log.Info("Unpacking " + nupkgPath + " to " + unpackagePath);

            binPaths[target.Name] = binPath;

            // Nuke any previously installed package
            UnzipPackage(nupkgPath, unpackagePath);

            if (IsMono)
            {
                Exec("chmod", "+x " + Path.Combine(binPath, "dnx"));
                Exec("chmod", "+x " + Path.Combine(binPath, "dnu"));
            }
        }

        // We need to run restore with the new runtime (just one of them)
        // On windows, grab a random windows target, otherwise use mono
        string path = null;
        
        if (CanBuildForWindows)
        {
            path = binPaths[RUNTIME_CLR_WIN_x86_NAME];
        }
        else
        {
            path = binPaths[RUNTIME_MONO_NAME];
        }
        
        ExecuteWithPath(path, () => 
        {
            DoRestore();
        });

        // Group by operation system since we only want to run unit tests on a single bitness
        // any = [dnx-mono]
        // win = [dnx-clr-win-x86, dnx-clr-win-x64, dnx-coreclr-win-x86, dnx-coreclr-win-x64]
        // darwin = [dnx-coreclr-darwin-x64]
        // linux = [dnx-coreclr-linux-x64]
        foreach (var group in RUNTIME_TARGETS.GroupBy(t => t.OS))
        {
            // Group by architecture since we only care about a single one for unit tests
            // any
            // any = [dnx-mono]

            // win
            
            // x86 = [dnx-clr-win-x86, dnx-coreclr-win-x86]
            // x64 = [dnx-clr-win-x64, dnx-coreclr-win-x64]

            // linux
            // x64 = [dnx-coreclr-linux-x64]

            // darwin
            // x64 [dnx-coreclr-darwin-x64]

            foreach (var target in group.GroupBy(t => t.Arch).First())
            {
                // Skip mono if we're not running on mono
                if (!IsMono && target.Flavor == "mono")
                {
                    continue;
                }
                
                // TODO: enable tests on darwin and linux after we get rid of ansi console color issue on CoreCLR
                if (target.OS == "darwin" || target.OS == "linux")
                {
                    continue;
                }
                
                var binPath = binPaths[target.Name];
                
                ExecuteWithPath(binPath, () =>
                {
                    foreach(var projectFile in Files.Include("test/*.Tests/project.json"))
                    {
                        var serializer = new JavaScriptSerializer();
                        var projectText = File.ReadAllText(projectFile);
                        var project = (Dictionary<string, object>)serializer.DeserializeObject(projectText);
    
                        object configsObject;
                        var configs = project.TryGetValue("frameworks", out configsObject)
                            ? (Dictionary<string, object>)configsObject
                            : new Dictionary<string, object>
                            {
                                { "dnx451", new Dictionary<string, object>() } // Assume dnx451 only if none specified
                            };
                        var targetFrameworks = configs.Keys.Where(k => k.StartsWith("dnx", StringComparison.OrdinalIgnoreCase));
                        foreach (var framework in targetFrameworks)
                        {
                            if(framework == target.Framework)
                            {
                                KTest(projectFile);
                                break;
                            }
                            else
                            {
                                continue;
                            }
                        }
                    }
                });
                
                // Functional tests run there own dnx versions
                // we only need to kick them off with Desktop CLR once
                if (target.Flavor == "coreclr")
                {
                    continue;
                }
                
                // Functional tests dont work on linux and osx yet
                if (target.OS == "darwin" || target.OS == "linux")
                {
                    continue;
                }
                
                ExecuteWithPath(binPath, () =>
                {
                    foreach(var projectFile in Files.Include("test/*.FunctionalTests/project.json"))
                    {
                        KTest(projectFile);
                    }
                });
            }
        }
    }

- // ===================== SHARED UTILITIES ===================== 
macro name='DoRestore'
    for each='var projectFile in Files.Include("src/*/project.json")'
        exec program='cmd' commandline='/C dnu restore' if='!IsMono' workingdir="${Path.GetDirectoryName(projectFile)}"
        exec program='dnu' commandline='restore' if='IsMono' workingdir="${Path.GetDirectoryName(projectFile)}"
    for each='var projectFile in Files.Include("test/*/project.json")'
        exec program='cmd' commandline='/C dnu restore' if='!IsMono' workingdir="${Path.GetDirectoryName(projectFile)}"
        exec program='dnu' commandline='restore' if='IsMono' workingdir="${Path.GetDirectoryName(projectFile)}"
    for each='var projectFile in Files.Include("samples/*/project.json")'
        exec program='cmd' commandline='/C dnu restore' if='!IsMono' workingdir="${Path.GetDirectoryName(projectFile)}"
        exec program='dnu' commandline='restore' if='IsMono' workingdir="${Path.GetDirectoryName(projectFile)}"

#update-tpa .copy-coreclr
    @{
        var envTrace = Environment.GetEnvironmentVariable("DNX_TRACE");

        try
        {
            var dotnetcoreclrDepFile = Path.Combine(BUILD_DIR2, "dotnetcoreclr-dependencies.txt");
            var tpacppFile = Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME, "tpa.cpp");
            var tpacppFileUnix = Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME + ".unix", "tpa.cpp");
            var runtimeCandidates = new[] {
                Path.Combine(CORECLR_TARGET_PATH, "Runtime", "win", "x86"),
            };
            
            Environment.SetEnvironmentVariable("DNX_TRACE", "0");

            if (IsMono)
            {
                var args = string.Format(@"list {0} --assemblies --runtime {1}",
                                        Path.Combine(ROOT, "src", BOOTSTRAPPER_HOST_NAME), 
                                        runtimeCandidates.First(Directory.Exists));

                ExecuteAndRedirectOutput("dnu", args, dotnetcoreclrDepFile);
            }
            else
            {
                var args = string.Format(@"/C dnu list {0} --assemblies --runtime {1}",
                                        Path.Combine(ROOT, "src", BOOTSTRAPPER_HOST_NAME),
                                        runtimeCandidates.First(Directory.Exists));
                ExecuteAndRedirectOutput("cmd", args, dotnetcoreclrDepFile);
            }

            var tpaProjects = new[] {
                BOOTSTRAPPER_HOST_NAME,
                BOOTSTRAPPER_CORECLR_MANAGED_NAME,
                "Microsoft.Framework.Runtime.Abstractions",
                "Microsoft.Framework.Runtime.Loader"
            };

            UpdateTpa(dotnetcoreclrDepFile, tpaProjects, tpacppFile);
            UpdateTpa(dotnetcoreclrDepFile, tpaProjects, tpacppFileUnix);
        }
        finally
        {
            Environment.SetEnvironmentVariable("DNX_TRACE", envTrace);
        }
    }
  
#ensure-clang
    @{
        if (CLANG == null || !File.Exists(CLANG))
        {
            Log.Warn("clang++ not found. Please ensure you have clang++ or clang++3.5 on the path or set CXX to a path to clang++.");
            Environment.Exit(1);
        }
    }

#ensure-msbuild
    @{
        if (!File.Exists(MSBUILD))
        {
            Log.Warn("msbuild version 14 not found. Please ensure you have the VS 2015 C++ SDK installed.");
            Environment.Exit(1);
        }
    }

#dev-install
    @{
        foreach (var target in RUNTIME_TARGETS)
        {
            InstallDevRuntime(target.TargetFolder);
        }
    }

functions @{
    private static readonly string _defaultLocalRuntimeHomeDir = ".dnx";
    private static readonly string _runtimesSubDir = "runtimes";

    void KTest(string projectFolder)
    {
        projectFolder = Path.GetDirectoryName(projectFolder);

        var testArgs = IsMono ? " -parallel none" : "";
        K(("test" + testArgs), projectFolder, "");
    }

    bool CanBuildForLinux
    {
        get 
        {
            return string.Equals(Uname(), "Linux");
        }
    }
    
    bool CanBuildForDarwin
    {
        get 
        {
            return string.Equals(Uname(), "Darwin");
        }
    }

    bool CanBuildForWindows
    {
        get 
        {
            var p = (int)Environment.OSVersion.Platform;
            return (p != 4) && (p != 6) && (p != 128);
        }
    }

    bool IsTravis 
    {
        get
        {
            var travis = Environment.GetEnvironmentVariable("TRAVIS");
            return string.Equals(travis, "true");
        }
    }

    public string Uname()
    {
        try
        {
            string uname;
            ExecuteAndRedirectOutput("uname", "", out uname);
            return string.IsNullOrEmpty(uname) ? null : uname.Trim();
        }
        catch 
        {
            return null;
        }
    }

    public string SearchForClang()
    {
        var CXX = Environment.GetEnvironmentVariable("CXX");

        if (!string.IsNullOrEmpty(CXX))
        {
            return CXX;
        }

        foreach(var dir in Environment.GetEnvironmentVariable("PATH").Split(Path.PathSeparator))
        {
            if (File.Exists(Path.Combine(dir, "clang++")))
            {
                return Path.Combine(dir, "clang++");
            }
            else if (File.Exists(Path.Combine(dir, "clang++-3.5")))
            {
                return Path.Combine(dir, "clang++-3.5");
            }
        }

        return null;
    }
    
    public void ExecuteWithPath(string binPath, Action action)
    {
        var envPath = Environment.GetEnvironmentVariable("PATH");

        try
        {
            // We want to run unit tests against all runtime targets
            Environment.SetEnvironmentVariable("PATH", binPath + Path.PathSeparator + envPath);
            Log.Info("Adding " + binPath + " to the PATH");

            action();
        }
        finally
        {
            Environment.SetEnvironmentVariable("PATH", envPath);
        }
    }

    void UpdateAllNuspecs(List<RuntimeTarget> targets, string sourcePath, string outputPath)
    {
        foreach (var target in targets)
        {
            var nuspecFile = Path.Combine(sourcePath, target.Name + ".nuspec");

            XDocument xdoc;
            using (var fs = File.OpenRead(nuspecFile))
            {
                xdoc = XDocument.Load(fs);
            }

            var filesNode = xdoc.Descendants("files").SingleOrDefault();

            foreach (var fileNode in filesNode.Elements("file"))
            {
                var srcAttr = fileNode.Attribute("src");
                if (srcAttr != null)
                {
                    srcAttr.Value = srcAttr.Value.Replace("\\", Path.DirectorySeparatorChar.ToString());
                }

                var excludeAttr = fileNode.Attribute("exclude");
                if (excludeAttr != null)
                {
                    excludeAttr.Value = excludeAttr.Value.Replace("\\", Path.DirectorySeparatorChar.ToString());
                }
            }

            var fileWriteTo = Path.Combine(outputPath, Path.GetFileName(nuspecFile));
            xdoc.Save(fileWriteTo);
        }
    }

    string FindRuntimeFolder()
    {
        var profileDirectory = Environment.GetEnvironmentVariable("USERPROFILE");

        if (string.IsNullOrEmpty(profileDirectory))
        {
            profileDirectory = Environment.GetEnvironmentVariable("HOME");
        }

        return Path.Combine(profileDirectory, _defaultLocalRuntimeHomeDir);
    }

    string FindRuntimePackagesFolder() 
    {
        return Path.Combine(FindRuntimeFolder(), _runtimesSubDir);
    }

    void InstallDevRuntime(string binPath)
    {
        var sourceDir = Path.GetDirectoryName(binPath);
        var sourceRuntime= Path.GetFileName(sourceDir);
        var destinationRuntime= sourceRuntime+ ".1.0.0-dev";
        var destinationDir = Path.Combine(FindRuntimePackagesFolder(), destinationRuntime);

        // Overwrite existing symbol link
        if (Directory.Exists(destinationDir)) 
        {
            Directory.Delete(destinationDir);
        }
    
        // Trim runtime name prefix part from alias to keep it short
        var alias = sourceRuntime.Substring(sourceRuntime.IndexOf('-') + 1) + "-dev";
    
        var symlinkProgram = "cmd";
        var symlinkProgramArgs = "/C mklink /J {0} {1}";
            
        var versionManagerProgram = "cmd";
        var versionManagerProgramArgs = "/C dnvm alias {0} {1}";
    
        if (IsMono)
        {
            symlinkProgram = "ln";
            symlinkProgramArgs = "-s {1} {0}";
            
            versionManagerProgram = "bash";
            versionManagerProgramArgs =
                "-c 'source " + 
                Path.Combine(FindRuntimeFolder(), "dnvm", "dnvm.sh") +
                " && dnvm alias {0} {1}'";
        }
    
        symlinkProgramArgs = String.Format(symlinkProgramArgs,
            destinationDir,
            sourceDir);
            
        versionManagerProgramArgs = String.Format(versionManagerProgramArgs,
            alias,
            destinationRuntime);
    
        Exec(symlinkProgram, symlinkProgramArgs);
        Exec(versionManagerProgram, versionManagerProgramArgs);
    }

    void FixShFiles(string directory)
    {
        // Rename all .sh files to remove the sh
        foreach (var shFile in Files.Include(Path.Combine(directory, "*.sh")))
        {
            var targetShFile = Path.Combine(Path.GetDirectoryName(shFile), 
                                            Path.GetFileNameWithoutExtension(shFile));
            if (File.Exists(targetShFile))
            {
                File.Delete(targetShFile);
            }

            // Make sure new lines are \n (\r\n messes up the bash script)
            var script = File.ReadAllText(shFile).Replace('\r\n', '\n');
            File.Move(shFile, targetShFile);
            File.WriteAllText(targetShFile, script);
        }
    }

    void UnzipPackage(string nupkgPath, string unpackagePath)
    {
        if (Directory.Exists(unpackagePath))
        {
            Log.Info("Deleting " + Path.GetDirectoryName(unpackagePath));
            Directory.Delete(Path.GetDirectoryName(unpackagePath), recursive:true);
        }

        Directory.CreateDirectory(unpackagePath);

        if (IsMono)
        {
            // System.IO.Compression gives weird errors on mono to do with invalid dates
            // we're going to use unzip instead
            Exec("unzip", nupkgPath + " -d " + unpackagePath);
        }
        else
        {
            System.IO.Compression.ZipFile.ExtractToDirectory(
                nupkgPath,
                unpackagePath);
        }
    }

    int ExecuteAndRedirectOutput(string command, string argument, out string content)
    {
        var procStartInfo = new ProcessStartInfo 
        {
            FileName = command, 
            Arguments = argument, 
            WorkingDirectory = Directory.GetCurrentDirectory(),
            UseShellExecute = false
        };
        procStartInfo.EnvironmentVariables["DNX_TRACE"] = "0";
        procStartInfo.RedirectStandardOutput = true;

        var process = Process.Start(procStartInfo);
        content = process.StandardOutput.ReadToEnd();
        process.WaitForExit();

        return process.ExitCode;
    }

    int ExecuteAndRedirectOutput(string command, string argument, string outputFile)
    {
        string content;
        int exitCode = ExecuteAndRedirectOutput(command, argument, out content);

        File.WriteAllText(outputFile, content);

        return exitCode;
    }

    HashSet<string> ListDependencyAssemblies(string projectFolder, string framework, string coreclrFolder = null)
    {
        var tmpFile = Path.GetTempFileName();
        var argument = string.Format("list {0} --framework {1} --assemblies", projectFolder, framework);

        if (coreclrFolder != null)
        {
            argument += (" --runtime " + coreclrFolder);
        }

        int result;
        if (!IsMono)
        {
            result = ExecuteAndRedirectOutput("cmd", string.Format("/C dnu {0}", argument), tmpFile);
        }
        else 
        {
            result = ExecuteAndRedirectOutput("dnu", argument, tmpFile);
        }

        if (result != 0)
        {
            throw new InvalidOperationException(string.Format("Return value for the command listing assemblies for project under {0} is not zero ({1}). Results are in temp file {2}.", projectFolder, result, tmpFile));
        }

        try
        {
            return new HashSet<string>(File.ReadAllLines(tmpFile).Where(l => File.Exists(l)));
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException(string.Format("Unexpected exception thrown while parsing assemblies list for project under {0}. ({1})", projectFolder, ex.Message));
        }
    }

    string[] FindAllProjects(params string[] folders)
    {
      return FindAllFiles("project.json", folders);
    }

    string[] FindAllFiles(string fileName, params string[] folders)
    {
      return folders.Select(folder => Path.Combine("src", folder)) 
                    .Where(folder => Directory.Exists(folder)) 
                    .SelectMany(folder => Directory.GetFiles(folder, fileName, SearchOption.AllDirectories)) 
                    .ToArray();
    }

    void UpdateTpa(string input, string[] assemblies, string output)
    {
        var tpa = File.ReadAllLines(input)
                      .Where(l => File.Exists(l))
                      .Select(l => Path.GetFileNameWithoutExtension(l))
                      .Concat(assemblies)
                      .OrderBy(s => s)
                      .ToArray();

        var content = new List<string>();

        content.Add(@"// Copyright (c) .NET Foundation. All rights reserved.");
        content.Add(@"// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.");
        content.Add(@"");
        content.Add(@"// This file will be dynamically updated during build to generate a ");
        content.Add(@"// minimal trusted platform assemblies list");
        content.Add(string.Empty);
        content.Add("#include \"stdafx.h\"");
        content.Add("#include \"tpa.h\"");
        content.Add(string.Empty);
        content.Add("BOOL CreateTpaBase(LPCTSTR** ppNames, size_t* pcNames, bool bNative)");
        content.Add("{");
        content.Add("    const size_t count = " + tpa.Length + ";");
        content.Add("    LPCTSTR* pArray = new LPCTSTR[count];");
        content.Add(string.Empty);
        content.Add("    if (bNative)");
        content.Add("    {");

        for (int i = 0; i < tpa.Length; ++i)
        {
            content.Add(string.Format("        pArray[{0}] = _T(\"{1}{2}\");", i, tpa[i], ".ni.dll"));
        }

        content.Add("    }");
        content.Add("    else");
        content.Add("    {");

        for (int i = 0; i < tpa.Length; ++i)
        {
            content.Add(string.Format("        pArray[{0}] = _T(\"{1}{2}\");", i, tpa[i], ".dll"));
        }

        content.Add("    }");
        content.Add(string.Empty);
        content.Add("    *ppNames = pArray;");
        content.Add("    *pcNames = count;");
        content.Add(string.Empty);
        content.Add("    return true;");
        content.Add("}");
        content.Add(string.Empty);
        content.Add("BOOL FreeTpaBase(const LPCTSTR* values)");
        content.Add("{");
        content.Add("    delete[] values;");
        content.Add(string.Empty);
        content.Add("    return true;");
        content.Add("}");

        File.WriteAllLines(output, content);
    }

    public class RuntimeTarget
    {
        public string Name { get; set; }
        public string TargetFolder { get; set; }
        public string Framework { get; set; }
        public string Arch { get; set; }
        public string OS { get; set; }
        public string Flavor { get; set; }
    }
}
